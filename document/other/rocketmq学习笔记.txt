一. 环境安装
1. 下载, 到地址https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.2/rocketmq-all-4.5.2-bin-release.zip
2. 解压到自定义目录下.
3. 配置ROCKETMQ_HOME环球变量
4. 启动, 先启动start mqnamesrv.cmd, 然后启动start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true
   如果启动正常会有一个窗口出来, 不要关闭. 如果启动异常, 在弹出的窗口里面会有异常提示, 比如内在太小等.

二. 为什么用rocketmq,(引用官方文档说明)
  根据我们的研究，随着使用越来越多的队列和虚拟主题，ActiveMQ IO模块遇到了瓶颈。我们尽力通过节流，断路器或降级来解决此问题，
  但效果不佳。因此，我们那时开始关注流行的消息传递解决方案Kafka。不幸的是，Kafka不能满足我们的要求，特别是在低延迟和高可靠
  性方面，请参阅此处以了解详细信息。
  在这种情况下，我们决定发明一个新的消息传递引擎来处理更广泛的用例集，从传统的发布/订阅方案到大批量实时零损失容忍交易系统。
  我们认为此解决方案可能是有益的，因此我们希望向社区开放它。如今，已有100多家公司在其业务中使用RocketMQ的开源版本

三.   核心理念
1. 生产者
   生产者将业务应用程序系统生成的消息发送给代理。RocketMQ提供了多种发送范例：同步，异步和单向。
2, 生产者组
   具有相同角色的生产者被分组在一起。如果原始生产者在交易后崩溃，则经纪人可以联系同一生产者组的不同生产者实例以提交或回滚交易。
3. 消费者
   消费者从经纪人那里获取消息，并将其输入到应用程序中。从用户应用的角度来看，提供了两种类型的使用者：
   3.1 拉取型消费者
       拉消费者主动从经纪人那里拉消息。一旦提取了成批的消息，用户应用程序就会启动使用过程。
   3.2 推送型消费者
       另一方面，推使用者将消息拉取，消耗进度和维护其他工作封装在内，将回调接口留给最终用户来实现，该接口将在消息到达时执行。
4. 消费群体
   与前面提到的生产者组相似，角色完全相同的消费者被分组在一起并命名为Consumer Group。
   消费者组是一个很棒的概念，通过它，在消息消耗方面实现负载平衡和容错的目标非常容易。
   警告：使用者组的使用者实例必须具有完全相同的主题订阅。
5. 主题
   主题是生产者传递消息而消费者提取消息的类别。主题与生产者和消费者之间的关系非常松散。具体来说，一个主题可能有零个，一个或
   多个向其发送消息的生产者。相反，生产者可以发送不同主题的消息。从消费者的角度来看，一个主题可以由零个，一个或多个消费者组
   订阅。与此类似，消费者组可以订阅一个或多个主题，只要该组的实例保持其订阅一致即可。
6. 消息
   消息是要传递的信息。消息中必须包含一个主题，该主题可以解释为要发送给您的信的地址。消息还可能具有可选标签和额外的键值对。
   例如，您可以为消息设置业务密钥，然后在代理服务器上查找消息以在开发过程中诊断问题。
7. 消息队列
   主题分为一个或多个子主题，即“消息队列”。
8. 标签
   标签（换句话说，子主题）为用户提供了额外的灵活性。使用标签，来自同一业务模块的目的不同的消息可能具有相同的主题和不同的
   标签。标签将有助于保持代码整洁和一致，标签还可以简化RocketMQ提供的查询系统。
9. 经纪人
   经纪人是RocketMQ系统的主要组成部分。它接收从生产者发送的消息，进行存储，并准备处理来自消费者的拉取请求。它还存储与消息
   相关的元数据，包括使用者组，使用者进度偏移量和主题/队列信息。
10. 名称伺服器
    名称服务器充当路由信息提供者。生产者/消费者客户查找主题以查找相应的经纪人列表。
11. 消息模型
    a. 聚类
    b. 广播
12. 消息顺序
    使用DefaultMQPushConsumer时，您可以决定按顺序或同时使用消息。
    a.顺序的:
      有序地使用消息意味着消息的消费顺序与生产者为每个消息队列发送消息的顺序相同。如果要处理必须强制执行全局顺序的情况，请确保您使用的主题只有一个消息队列。
      警告：如果指定了有序使用，则消息使用的最大并发度是使用方组订阅的消息队列数
    b.并发的:
      当并发使用消息时，消息使用的最大并发性仅受为每个消费者客户端指定的线程池限制。
      警告：在此模式下不再保证消息顺序。











